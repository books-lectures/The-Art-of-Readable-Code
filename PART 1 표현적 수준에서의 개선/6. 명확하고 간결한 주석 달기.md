```
💡 주석은 높은 ‘정보 대 공간’ 비율을 갖춰야 한다.
```

# 1. 주석을 간결하게 하라

## BAD:

```cpp
// int는 CategoryType이다.
// 내부 페어의 첫 번째 float는 'score'다.
// 두 번째는 'weight'다.
typedef hash_map<int, pair<float, float> > ScoreMap;
```

주석이 길어야할 때도 있지만 적어도 위 같은 경우는 아니다.

## GOOD:

```cpp
// CategoryType -> (score, weight)
typedef hash_map<int, pair<float, float> > ScoreMap;
```

# 2. 모호한 대명사는 피하라

## BAD:

```cpp
// Insert the data into the cache, but check if **it's** too big first
// 데이터를 캐시에 넣어라. 하지만 **그것**이 너무 큰지 먼저 확인하라.
```

이 주석에서 ‘it(그것)’은 데이터를 가리킬 수도 있고 캐시를 가리킬 수도 있다. 이런 혼동의 여지가 없도록 대명사를 명사로 대체하자.

## GOOD:

```cpp
// Insert the data into the cache, but check if **the data** is too big first.
// 데이터를 캐시에 넣어라. 하지만 **데이터**가 너무 큰지 먼저 확인하라.
```

또한 ‘it’을 완전히 명확하게 하기 위해서 문장을 고칠 수도 있다.

## GOOD:

```cpp
// if the data is small enough, insert it into the cache.
// 데이터가 충분히 작으면, 이를 캐시에 넣어라.
```

# 3. 엉터리 문장을 다듬어라

## BAD:

```python
# 이 URL을 전에 이미 방문했는지에 따라서 다른 우선순위를 부여한다.
```

## GOOD:

```python
# 전에 방문하지 않은 URL에 높은 우선순위를 부여하라.
```

아래 문장이 더 간단하고 짧고, 직접적이다. 또한 아직 방문하지 않은 URL에 높은 우선수위가 부여된다는 사실까지 설명한다.

# 4. 함수의 동작을 명확하게 설명하라

## BAD:

```cpp
// 이 파일에 담긴 줄 수를 반환한다.
int CountLines(string filename) { ... }
```

이 주석은 그다지 명확하지 않다. ‘줄’을 정의하는 방법이 다음과 같이 많기 때문이다.

- “”(빈 파일)은 줄 수가 0인가 1인가?
- “hello”는 줄 수가 0인가 1인가?
- “hello\n”은 줄 수가 1인가 2인가?
- “hello\n world”는 줄 수가 1인가 2인가?
- “hello\n\r cruel\n world\r”은 줄 수가 2, 3, 4 중 어느 것인가?

가장 간단한 구현은 단순히 \n을 세는 것이다.

## GOOD:

```cpp
// 파일 안에 새 줄을 나타내는 바이트('\n')가 몇 개 있는지 센다.
int CountLines(string filename) { ... }
```

이 주석은 이전 주석에 비해 그리 길어지지는 않았지만 다음과 같은 훨씬 더 많은 정보를 담는다.

- 캐리지 반환문자(\r)는 무시될 것이다.
- 개행문자가 없으면 0이 반환될 것이다.

# 5. 코너케이스를 설명해주는 입/출력 예를 사용하라

## BAD:

```java
// pivot보다 작은 요소가 pivot과 크거나 같은 요소들보다 앞에 오도록 'v'를 재배열한다.
// 그 다음 v[i] < pivot을 만족시키는 것 중에서 가장 큰 'i'를 (혹은 pivot보다 작은 것이
// 없으면 -1을) 반환한다.
int Partition(vector<int>* v, int pivot);
```

이 주석은 대단히 명확하지만, 시각적으로는 다소 혼란스럽다.

## GOOD:

```java
// ...
// 예: Partition([8 5 9 8 2], 8)은 [5 2 | 8 9 8]를 만들고 1을 반환할 것이다.
int Partition(vector<int>* v, int pivot);
```

몇 군데 짚고 넘어갈 부분이 있다.

- 벡터 안에 존재하는 값을 `pivot`으로 사용하여 경계가 분할되는 방식을 설명한다.
- 벡터가 중복된 값을 허용한다는 사실을 보여주기 위해서 중복된 값(8)을 포함시켰다.
- 중복된 값(8)을 포함시켜 벡터가 중복된 값을 허용한다는 사실을 보여준다.
- 결과값을 담은 벡터를 일부러 정렬하지 않았다. 만약 정렬하면 혼동을 초래할 것이다.
- 반환된 값이 1이므로, 벡터에 1이 포함되지 않게 했다. 1이 포함되면 혼동을 초래할 것이다.

# 6. 코드의 의도를 명시하라

## BAD:

```java
void DisplayProducts(list<Product> products) {
  products.sort(CompareProductByPrice);

  // 리스트를 역순으로 반복한다.
  for (
    list<Product>::reverse_iterator it = products.rbegin();
    it != products.rend();
    it += 1
  ) {
    DisplayPrice(it->price);
  }
}
```

이 주석은 바로 아래에 있는 코드의 묘사만 전달할 뿐이다. 대신 더 좋은 주석을 생각 해보자.

## GOOD:

```java
...
// 각 가격을 높은 값에서 낮은 값 순으로 나타낸다.
for (
  list<Product>
  ...
```

이 주석은 프로그램이 수행하는 동작을 개략적인 높은 수준에서 설명한다. 프로그래머가 코드를 작성하는 동안 생각했던 것에 더 가까운 설명인 것이다.

그런데 흥미롭게도 이 프로그램에는 버그가 있다! 여기서는 보여주지 않았지만 `CompareProductByPrice`는 가격을 이미 높은 값에서 낮은 값으로 정렬했다. 따라서 이 코드는 프로그래머가 의도한 바와 오히려 반대되는 일을 수행한다.

이런 이유 때문에 두 번째 주석이 더 좋다. 버그가 있음에도 첫 번째 주석은 기술적으로 틀린 게 없다. 루프 자체는 주석대로 역순으로 반복하기 때문이다. 하지만 두 번째 주석은 코드가 실제로 수행하는 일이 그와 반대라는 사실을 더 잘 눈치 챌 수 있다. 이런 주석은 실질적으로 중복검사의 역할을 수행한다.

궁극적으로 가장 최선의 중복검사는 유닛테스트다(14장 테스트와 가독성 참고). 하지만 프로그램의 의도를 설명해주는 주석을 다는 행위에는 의미가 있다.

# 7. 이름을 가진 함수(Named Function) 파라미터 주석

```java
Connect(10, false);
```

```python
Connect(timeounht = 10, use_encryption = false);
```

이 함수 호출은 함수에 주어진 정수와 불리언값이 무엇을 뜻하는지 불분명하기 때문에 명확하지 않다.

파이썬 같은 언어는 이름과 함께 인수를 전달할 수 있다. 하지만 C++와 Java 같은 언어는 이렇게 할 수 없다. 하지만 바로 옆에 주석을 넣어 같은 효과를 얻을 수 있다.

## GOOD:
```java
Connect(/* timeout_ms = */ 10, /* use_encryption = */ false);
```

불리언 인수와 관련해서는 `/* name = */`이라는 주석을 값의 앞에 놓는 것이 특히 중요하다. 주석을 값의 뒤에 놓으면 혼란을 초래하기 때문이다.

## BAD:
```java
Connect(..., false /* use_encryption */);
Connect(..., false /* = use_encryption */);
```

이러한 예에서는 `false`가 “암호화를 사용하라”는 사실을 뜻하는지 아니면 “암호화를 사용하지 말라”를 뜻하는지 분명하지 않다.

# 8. 정보 축약형 단어를 사용하라

## BAD:

```java
// 이 클래스는 데이터베이스와 동일한 정보를 담는 멤버를 가지고 있는데, 이는
// 속도를 향상시키는 데 사용된다. 나중에 이 클래스가 읽히면, 멤버들이 어떤 값을
// 가졌는지 확인하고, 만약 값이 있으면 그 값이 반환된다. 값이 없으면
// 데이터베이스에서 값이 읽혀져서 나중에 이용될 수 있게 멤버가 저장된다.
```

## GOOD:

```java
// 이 클래스는 데이터베이스에 대한 캐시 계층으로 기능한다.
```

---

## BAD:

```java
// 주소값에서 불필요한 빈 칸을 제거한다. 그리고 "Avenue"를 "Ave."로 바꾸는 것과
// 같은 정리 작업을 수행한다. 이러한 과정으로 사실상 같지만 다르게 입력된
// 주소는 동일한 방식으로 정리된 값을 갖게 되어 동일한 주소를 가지는지를
// 값들을 서로 비교해서 확인할 수 있다.
```

## GOOD:

```java
// 주소값을 표준화한다
// (불필요한 빈칸을 제거하고, "Avenue" -> "Ave." 등의 정리 작업을 수행한다).
```

`경험적인(heuristic)`, `주먹구구식(brute-force)`, `순진한 해법(native solution)`과 같이 다양한 의미를 함축하는 단어나 표현이 많다. 길게 늘어지는 주석을 써야 할 때 전형적인 상황을 묘사하는 표현이 있는지 확인하는 편이 좋다.
